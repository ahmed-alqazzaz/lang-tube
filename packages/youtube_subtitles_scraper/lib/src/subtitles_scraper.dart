import 'dart:async';
import 'dart:developer';
import 'package:languages/languages.dart';
import 'package:youtube_subtitles_scraper/src/data/source_subtitles.dart';
import 'package:youtube_subtitles_scraper/src/youtube_explode_manager.dart';

import '../youtube_subtitles_scraper.dart';

final class YoutubeSubtitlesScraper {
  YoutubeSubtitlesScraper({
    required CacheManager cacheManager,
    required SubtitlesScraperApiClient apiClient,
  })  : _cacheManager = cacheManager,
        _apiClient = apiClient,
        _youtubeExplodeManager = YoutubeExplodeManager(
          cacheManager: cacheManager,
        );
  final CacheManager _cacheManager;
  final SubtitlesScraperApiClient _apiClient;
  final YoutubeExplodeManager _youtubeExplodeManager;
  int _recusrsionCount = 0;

  // in case translated language is provided,
  // the function will return a translated version
  // the main language subtitle
  Future<List<ScrapedSubtitles>?> scrapeSubtitles({
    required String youtubeVideoId,
    required Language language,
    Language? translatedLanguage,
  }) async {
    // check if cache exists
    final cacheSubtitles = await _cacheManager.retrieveSubtitles(
      videoId: youtubeVideoId,
      language: language.name,
    );
    if (cacheSubtitles != null) return cacheSubtitles.toList();

    // in case no cache found
    final sourceCaptions = await _youtubeExplodeManager.fetchSourceCaptions(
        youtubeVideoId: youtubeVideoId, language: language);
    final subtitles = await Future.wait(
      sourceCaptions.map(
        (caption) => _scrapeAndCacheSubtitles(
          youtubeVideoId: youtubeVideoId,
          sourceCaptions: translatedLanguage == null
              ? caption
              : caption.autoTranslate(translatedLanguage),
          language: translatedLanguage ?? language,
        ),
      ),
    ).onError((error, stackTrace) async {
      if (error is SubtitlesScraperBlockedRequestException &&
          _recusrsionCount < 1) {
        await _youtubeExplodeManager.deleteCacheById(videoId: youtubeVideoId);
        _recusrsionCount++;
        return await scrapeSubtitles(
          youtubeVideoId: youtubeVideoId,
          language: language,
          translatedLanguage: translatedLanguage,
        ).then((subtitles) => subtitles ?? []);
      }
      throw error!;
    });

    _recusrsionCount = 0;
    return subtitles.isEmpty ? null : subtitles;
  }

  // stream of the progress of the currently scraped subtitles where 0.0 < value < 1.0
  Stream<double> get activeProgress => _apiClient.activeProgress;

  Future<ScrapedSubtitles> _scrapeAndCacheSubtitles({
    required String youtubeVideoId,
    required SourceCaptions sourceCaptions,
    required Language language,
  }) async {
    final subtitles = await _apiClient.fetchSubtitles(
      url: sourceCaptions.uri,
    );
    log("123 source $sourceCaptions lang ${language.name}");
    _cacheManager.cacheSubtitles(
      subtitles: subtitles,
      language: language.name,
      isSubtitlesAutoGenerated: sourceCaptions.isAutoGenerated,
      videoId: youtubeVideoId,
    );
    return ScrapedSubtitles(
      subtitles: subtitles,
      isAutoGenerated: sourceCaptions.isAutoGenerated,
    );
  }

  Future<void> dispose() async {
    await _apiClient.close();
    _youtubeExplodeManager.close();
  }
}
