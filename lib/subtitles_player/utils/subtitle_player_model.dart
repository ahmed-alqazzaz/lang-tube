// ignore_for_file: public_member_api_docs, sort_constructors_first
import 'package:flutter/foundation.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/data/data.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

import 'package:lang_tube/subtitles_player/utils/subtitles_parser/subtitles_parser.dart';

class SubtitlePlayerModel extends ChangeNotifier {
  SubtitlePlayerModel({
    required this.mainSubtitlesController,
    required this.translatedSubtitlesController,
    required YoutubePlayerController youtubePlayerController,
  }) : _youtubePlayerController = youtubePlayerController {
    _youtubePlayerController.addListener(youtubePlayerListener);
  }

  final SubtitlesController mainSubtitlesController;
  final SubtitlesController translatedSubtitlesController;
  final YoutubePlayerController _youtubePlayerController;

  void youtubePlayerListener() {
    final isProgressBarBeingDragged = _youtubePlayerController.value.isDragging;
    for (final subtitles in [
      mainSubtitlesController,
      translatedSubtitlesController
    ]) {
      if (!isProgressBarBeingDragged) {
        subtitles.notifyDurationChange(
          duration: _youtubePlayerController.value.position,
          onSubtitleUpdated: () {
            notifyListeners();
          },
        );
      } else {
        subtitles.hideSubtitles(
          onSubtitleUpdated: () {
            notifyListeners();
          },
        );
      }
    }
  }

  @override
  void dispose() {
    _youtubePlayerController.removeListener(youtubePlayerListener);
    super.dispose();
  }
}

class SubtitlesController {
  final SubtitlesParser _subtitlesParser;

  final List<Subtitle> subtitles;
  final bool isAutoGenerated;

  int? currentSubtitleIndex;
  Subtitle? get currentSubtitle =>
      currentSubtitleIndex != null ? subtitles[currentSubtitleIndex!] : null;

  void notifyDurationChange(
      {required Duration duration, required Function() onSubtitleUpdated}) {
    final updatedSubtitleIndex = _subtitlesParser.searchDuration(duration);
    if (updatedSubtitleIndex != currentSubtitleIndex) {
      currentSubtitleIndex = updatedSubtitleIndex;
      onSubtitleUpdated();
    }
  }

  void hideSubtitles({required Function() onSubtitleUpdated}) {
    if (currentSubtitleIndex != null) {
      currentSubtitleIndex = null;
      onSubtitleUpdated();
    }
  }

  SubtitlesController({
    required SubtitlesParser subtitlesParser,
    required this.isAutoGenerated,
    this.currentSubtitleIndex,
  })  : _subtitlesParser = subtitlesParser,
        subtitles = subtitlesParser.subtitles;

  factory SubtitlesController.fromSubtitlesEntry(
      SubtitlesEntry subtitlesEntry) {
    return SubtitlesController(
      subtitlesParser: subtitlesEntry.subtitlesParser,
      isAutoGenerated: subtitlesEntry.isAutoGenerated,
    );
  }

  @override
  bool operator ==(covariant SubtitlesController other) {
    if (identical(this, other)) return true;

    return other._subtitlesParser == _subtitlesParser &&
        listEquals(other.subtitles, subtitles) &&
        other.isAutoGenerated == isAutoGenerated &&
        other.currentSubtitleIndex == currentSubtitleIndex;
  }

  @override
  int get hashCode {
    return _subtitlesParser.hashCode ^
        subtitles.hashCode ^
        isAutoGenerated.hashCode ^
        currentSubtitleIndex.hashCode;
  }

  @override
  String toString() {
    return 'SubtitlesInfo(_subtitlesParser: $_subtitlesParser, subtitles: $subtitles, isAutoGenerated: $isAutoGenerated, currentSubtitleIndex: $currentSubtitleIndex)';
  }
}
