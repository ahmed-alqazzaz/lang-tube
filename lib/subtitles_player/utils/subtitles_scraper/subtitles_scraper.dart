import 'dart:developer';

import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:lang_tube/subtitles_player/utils/api_client/dio_api_client.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_parser/subtitles_parser.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/cache_manager.dart/subtitles_type.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/data/extensions.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/cache_manager.dart/subtitles_cache_manager.dart';

import 'package:youtube_explode_dart/youtube_explode_dart.dart';

import 'data/exceptions.dart';
import 'data/types.dart';

@immutable
class SubtitlesScraper {
  const SubtitlesScraper._({
    required DioApiClient client,
    required SubtitlesCacheManager cacheManager,
    required YoutubeExplode yt,
  })  : _client = client,
        _cacheManager = cacheManager,
        _yt = yt;

  final SubtitlesCacheManager _cacheManager;
  final DioApiClient _client;
  final YoutubeExplode _yt;

  static Future<SubtitlesScraper> withRandomUserAgent() async =>
      SubtitlesScraper._(
        client: await DioApiClient.withRandomUserAgent(),
        cacheManager: await SubtitlesCacheManager.open(),
        yt: YoutubeExplode(),
      );

  static Future<SubtitlesScraper> withUserAgent(String userAgent) async =>
      SubtitlesScraper._(
        client: await DioApiClient.withUserAgent(userAgent),
        cacheManager: await SubtitlesCacheManager.open(),
        yt: YoutubeExplode(),
      );

  // returns a stream of manually generated subtitles if they exist
  //  otherwise return autoGenerated
  Stream<SubtitlesBundle> getSubtitle({
    required String youtubeVideoId,
    required ({String mainLanguage, String translatedLanguage}) languages,
  }) async* {
    final manifest = await _yt.videos.closedCaptions
        .getManifest(youtubeVideoId, formats: [ClosedCaptionFormat.srv1]);

    final captions = (manifest.containsManuallyGenerated
            ? manifest.manuallyGeneratedCaptions
            : manifest.autoGeneratedCaptions)
        .where(
      (element) => element.language.name.toLowerCase().contains(
            languages.mainLanguage.toLowerCase(),
          ),
    );
    for (final element in captions) {
      log(element.language.name);
    }
    final translatedCaption =
        manifest.getByLanguage(languages.translatedLanguage).firstOrNull;

    final isAutoGenerated = !manifest.containsManuallyGenerated;

    for (final caption in captions) {
      yield (
        mainLanguageSubtitles: await _subtitlesEntryGenerator(
          caption: caption,
          isAutoGenerated: isAutoGenerated,
          fileName: SubtitlesCacheManager.fileNameGenerator(
            type: SubtitlesType.main,
            youtubeVideoId: youtubeVideoId,
          ),
        ),
        // change en
        translatedSubtitles: await _subtitlesEntryGenerator(
          caption: translatedCaption ?? caption.autoTranslate('en'),
          isAutoGenerated: translatedCaption == null,
          fileName: SubtitlesCacheManager.fileNameGenerator(
            type: SubtitlesType.translated,
            youtubeVideoId: youtubeVideoId,
          ),
        ),
      );
    }
  }

  Future<SubtitlesEntry> _subtitlesEntryGenerator({
    required ClosedCaptionTrackInfo caption,
    required String fileName,
    required bool isAutoGenerated,
  }) async {
    return (
      subtitlesParser: SubtitlesParser(
        await _cacheManager.retrieveSubtitlesIfExists(fileName: fileName) ??
            await _fetchUri<String>(caption.url).then(
              (subtitlesString) async {
                await _cacheManager.cacheSubtitles(
                  subtitlesString: subtitlesString,
                  fileName: fileName,
                );
                return subtitlesString;
              },
            ),
      ),
      isAutoGenerated: isAutoGenerated,
    );
  }

  Future<T> _fetchUri<T>(Uri uri) async {
    try {
      return await _client.fetchUri(uri).then((response) {
        if (response.statusCode != 200) {
          throw SubtitlesScraperBlockedRequestException();
        }
        return response.data!;
      });
    } on DioError catch (e) {
      if (e.error == DioErrorType.sendTimeout ||
          e.type == DioErrorType.connectionTimeout ||
          e.type == DioErrorType.receiveTimeout) {
        throw SubtitlesScraperNetworkException();
      } else if (e.error == DioErrorType.badResponse) {
        throw SubtitlesScraperBlockedRequestException();
      } else {
        throw SubtitlesScraperUnknownException();
      }
    }
  }
}
