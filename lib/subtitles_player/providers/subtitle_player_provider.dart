// ignore_for_file: public_member_api_docs, sort_constructors_first
import 'dart:developer';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/data/data_classes.dart';
import 'package:lang_tube/subtitles_player/utils/subtitles_scraper/subtitles_scraper.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

import 'package:lang_tube/subtitles_player/utils/subtitles_parser/subtitles_parser.dart';

typedef SubtitlesPlayerProvider
    = AutoDisposeChangeNotifierProvider<SubtitlesPlayerModel>;

KeepAliveLink? subtitlesPlayerProviderkeepAliveLink;
SubtitlesPlayerProvider subtitlesPlayerProviderBuilder({
  required YoutubePlayerController youtubePlayerController,
  required SubtitlesController mainSubtitlesController,
  required SubtitlesController translatedSubtitlesController,
}) {
  return ChangeNotifierProvider.autoDispose<SubtitlesPlayerModel>(
    (ref) {
      subtitlesPlayerProviderkeepAliveLink = ref.keepAlive();
      return SubtitlesPlayerModel(
        mainSubtitlesController: mainSubtitlesController,
        translatedSubtitlesController: translatedSubtitlesController,
        youtubePlayerController: youtubePlayerController,
      );
    },
  );
}

class SubtitlesPlayerModel extends ChangeNotifier {
  SubtitlesPlayerModel({
    required this.mainSubtitlesController,
    required this.translatedSubtitlesController,
    required YoutubePlayerController youtubePlayerController,
  }) : _youtubePlayerController = youtubePlayerController {
    log('instantiated subtitles listener');
    _youtubePlayerController.addListener(youtubePlayerListener);
  }
  final SubtitlesController mainSubtitlesController;
  final SubtitlesController translatedSubtitlesController;
  final YoutubePlayerController _youtubePlayerController;

  void seekTo(Duration duration) {
    _youtubePlayerController.seekTo(duration);
    _youtubePlayerController.value.isPlaying
        ? null
        : _youtubePlayerController.play();
  }

  void pause() => _youtubePlayerController.value.isPlaying
      ? _youtubePlayerController.pause()
      : null;

  void youtubePlayerListener() {
    final isProgressBarBeingDragged = _youtubePlayerController.value.isDragging;
    for (final subtitles in [
      mainSubtitlesController,
      translatedSubtitlesController
    ]) {
      if (!isProgressBarBeingDragged) {
        subtitles.notifyDurationChange(
          duration: _youtubePlayerController.value.position,
          onSubtitleUpdated: () {
            notifyListeners();
          },
        );
      } else {
        subtitles.hideSubtitles(
          onSubtitleUpdated: () {
            notifyListeners();
          },
        );
      }
    }
  }

  @override
  void dispose() {
    _youtubePlayerController.removeListener(youtubePlayerListener);
    super.dispose();
  }
}

class SubtitlesController {
  final SubtitlesParser _subtitlesParser;

  final List<Subtitle> subtitles;
  final bool isAutoGenerated;

  int? currentSubtitleIndex;

  int get subtitlesCount => subtitles.length;
  Subtitle? get currentSubtitle =>
      currentSubtitleIndex != null ? subtitles[currentSubtitleIndex!] : null;

  void notifyDurationChange({
    required Duration duration,
    required Function() onSubtitleUpdated,
  }) {
    final updatedSubtitleIndex = _subtitlesParser.searchDuration(duration);
    if (updatedSubtitleIndex != currentSubtitleIndex) {
      currentSubtitleIndex = updatedSubtitleIndex;
      onSubtitleUpdated();
    }
  }

  void hideSubtitles({required Function() onSubtitleUpdated}) {
    if (currentSubtitleIndex != null) {
      currentSubtitleIndex = null;
      onSubtitleUpdated();
    }
  }

  SubtitlesController({
    required SubtitlesParser subtitlesParser,
    required this.isAutoGenerated,
    this.currentSubtitleIndex,
  })  : _subtitlesParser = subtitlesParser,
        subtitles = subtitlesParser.subtitles;

  factory SubtitlesController.fromSubtitlesEntry(
      SubtitlesEntry subtitlesEntry) {
    return SubtitlesController(
      subtitlesParser: subtitlesEntry.subtitlesParser,
      isAutoGenerated: subtitlesEntry.isAutoGenerated,
    );
  }

  @override
  bool operator ==(covariant SubtitlesController other) {
    if (identical(this, other)) return true;

    return other._subtitlesParser == _subtitlesParser &&
        listEquals(other.subtitles, subtitles) &&
        other.isAutoGenerated == isAutoGenerated &&
        other.currentSubtitleIndex == currentSubtitleIndex;
  }

  @override
  int get hashCode {
    return _subtitlesParser.hashCode ^
        subtitles.hashCode ^
        isAutoGenerated.hashCode ^
        currentSubtitleIndex.hashCode;
  }

  @override
  String toString() {
    return 'SubtitlesInfo(_subtitlesParser: $_subtitlesParser, subtitles: $subtitles, isAutoGenerated: $isAutoGenerated, currentSubtitleIndex: $currentSubtitleIndex)';
  }
}
