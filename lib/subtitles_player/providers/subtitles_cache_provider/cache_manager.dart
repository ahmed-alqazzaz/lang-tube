import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart'
    as subtitles_scraper;
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart';

import 'database_manager/data/cached_subtitle.dart';
import 'database_manager/data/cached_source_captions.dart';
import 'database_manager/data/constants.dart';
import 'database_manager/manager.dart';

@immutable
final class SubtitlesCacheManager implements subtitles_scraper.CacheManager {
  const SubtitlesCacheManager._(this._dbManager);
  final SubtitlesDbManager _dbManager;

  static Future<SubtitlesCacheManager> open() async => SubtitlesCacheManager._(
        await SubtitlesDbManager.open('${await _cachePath}$subtitlesDbName'),
      );

  @override
  Future<void> cacheSubtitles(ScrapedSubtitles scrapedSubtitles) async {
    await _dbManager.addVideoIdIfNotPresent(scrapedSubtitles.videoId);
    final subtitlesInfoId = await _dbManager.insertSubtitlesInfoIfNotPresent(
      videoId: scrapedSubtitles.videoId,
      language: scrapedSubtitles.language?.name ?? 'unkown',
      isAutoGenerated: scrapedSubtitles.isAutoGenerated,
    );
    await _dbManager.insertSubtitles(
      subtitles: scrapedSubtitles.subtitles,
      subtitlesInfoId: subtitlesInfoId,
    );
  }

  @override
  Future<void> cacheSourceCaptions(SourceCaptions captions) async {
    await _dbManager.addVideoIdIfNotPresent(captions.videoId);
    final subtitlesInfoId = await _dbManager.insertSubtitlesInfoIfNotPresent(
      videoId: captions.videoId,
      language: captions.language?.name ?? 'unknown',
      isAutoGenerated: captions.isAutoGenerated,
    );
    await _dbManager.insertSubtitlesSource(
      subtitlesSource: captions.uri.toString(),
      subtitlesInfoId: subtitlesInfoId,
    );
  }

  @override
  Future<Iterable<CachedSubtitles>?> retrieveSubtitles(
          {String? videoId, String? language}) async =>
      await _dbManager.retrieveSubtitles().then((subtitlesList) {
        subtitlesList = subtitlesList.where(
          (subtitles) => videoId != null ? subtitles.videoId == videoId : true,
        );
        subtitlesList = subtitlesList.where(
          (subtitles) =>
              language != null ? subtitles.language?.name == language : true,
        );
        return subtitlesList.isNotEmpty ? subtitlesList : null;
      });

  @override
  Future<Iterable<CachedSourceCaptions>?> retrieveSources(
          {String? videoId, String? language}) async =>
      await _dbManager.retrieveAllSources().then(
        (sources) {
          sources = sources.where(
            (source) => videoId != null ? source.videoId == videoId : true,
          );
          sources = sources.where(
            (source) =>
                language != null ? source.language?.name == language : true,
          );
          return sources.isNotEmpty ? sources : null;
        },
      );

  @override
  Future<void> clearSubtitlesCache() => _dbManager.deleteAllSubtitles();
  @override
  Future<void> clearSources({String? videoId, bool? isAutoGenerated}) async {
    if (isAutoGenerated != null) assert(videoId != null);
    await _dbManager.deleteSubtitlesSources(
      videoId: videoId,
      isAutoGenerated: isAutoGenerated,
    );
  }

  Future<void> close() async => await _dbManager.close();

  static Future<String> get _cachePath async =>
      await getTemporaryDirectory().then((dir) => dir.path);
}
