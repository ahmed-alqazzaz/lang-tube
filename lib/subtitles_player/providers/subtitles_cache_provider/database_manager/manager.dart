import 'dart:developer';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_cache_provider/data/cached_subtitle.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_cache_provider/data/constants.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_cache_provider/utils/bool_to_int.dart';
import 'package:mutex/mutex.dart';

import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'data/exceptions.dart';

final mutex = Mutex();

@immutable
class SubtitlesDbManager {
  const SubtitlesDbManager._(this._db);
  final Database _db;
  Database get db => _db;
  static Future<SubtitlesDbManager> open(final String dbFilePath) async {
    if (Platform.isWindows) {
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }
    return SubtitlesDbManager._(
      await openDatabase(
        dbFilePath,
        version: 1,
        onCreate: (db, version) => db.execute(createSubtitlesTableCommand),
      ),
    );
  }

  Future<void> close() async {
    if (!_db.isOpen) throw const SubtitlesDataBaseIsClosedException();
    await _db.close();
  }

  Future<void> addSubtitles({
    required String subtitles,
    required String videoId,
    required String language,
    required bool isAutoGenerated,
  }) async {
    if (!_db.isOpen) throw const SubtitlesDataBaseIsClosedException();
    try {
      await mutex.acquire();
      await _db.insert(subtitlesTable, {
        subtitlesColumn: subtitles,
        isSubtitleAutoGeneratedColumn: boolToInt(isAutoGenerated),
        videoIdColumn: videoId,
        subtitlesLanguageColumn: language,
      });
    } on DatabaseException catch (e) {
      if (e.isUniqueConstraintError()) {
        throw const SubtitlesAlreadyExistsException();
      }
    } finally {
      mutex.release();
    }
  }

  Future<Iterable<CachedSubtitles>> retrieveSubtitles({
    required String videoId,
    required String language,
  }) async {
    if (!_db.isOpen) throw const SubtitlesDataBaseIsClosedException();
    try {
      await mutex.acquire();
      return await _db.query(
        subtitlesTable,
        where: '$videoIdColumn = ? AND $subtitlesLanguageColumn = ?',
        whereArgs: [videoId, language],
      ).then((result) {
        return result.map(
          (cachedSubtitle) => CachedSubtitles.fromMap(cachedSubtitle),
        );
      });
    } finally {
      mutex.release();
    }
  }
}
