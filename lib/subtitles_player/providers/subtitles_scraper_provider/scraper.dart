import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_bundle.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_data.dart';
import 'package:languages/languages.dart';
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart';
import 'package:subtitles_parser/subtitles_parser.dart' as subtitles_parser;
import 'package:subtitles_player/subtitles_player.dart' as subtitles_player;
import '../subtitles_cache_provider/cache_manager.dart';
import 'api_client.dart';
import 'data/exceptions.dart';
import 'package:quiver/iterables.dart';

@immutable
final class SubtitlesScraper {
  SubtitlesScraper({required this.cacheManager})
      : _scraper = YoutubeSubtitlesScraper(
          cacheManager: cacheManager,
          apiClient: ScraperApiClient(),
        );

  final YoutubeSubtitlesScraper _scraper;
  final SubtitlesCacheManager cacheManager;
  // Function to fetch and process subtitles for a YouTube video in different languages.
  Future<Iterable<SubtitlesBundle>> fetchSubtitlesBundle({
    required String youtubeVideoId,
    required Language mainLanguage,
    required Language translatedLanguage,
  }) async {
    // concurrently fetch list main and translated subs
    return await Future.wait<Iterable<SubtitlesData>>([
      () async {
        return await _fetchCache(
              youtubeVideoId: youtubeVideoId,
              language: mainLanguage,
            ).then((value) {
              if (value == null) {
                log("main cache is null");
              }
              return value;
            }) ??
            await scrapeSubtitles(
              youtubeVideoId: youtubeVideoId,
              language: mainLanguage,
            ) ??
            (throw SubtitlesScraperNoCaptionsFoundException);
      }(),
      () async {
        return await _fetchCache(
              youtubeVideoId: youtubeVideoId,
              language: translatedLanguage,
            ).then((value) {
              if (value == null) {
                log("tranlated cache is null");
              }
              return value;
            }) ??
            await scrapeSubtitles(
              youtubeVideoId: youtubeVideoId,
              language: mainLanguage,
              translatedLanguage: translatedLanguage,
            ) ??
            (throw SubtitlesScraperNoCaptionsFoundException);
      }()
    ], eagerError: true)
        .then(
      (subtitlesPair) {
        // zip the list(of two) returned by future.wait
        return zip(subtitlesPair).map(
          (pair) => SubtitlesBundle(
            mainSubtitlesData: pair.first,
            translatedSubtitlesData: pair.last,
          ),
        );
      },
    );
  }

  // in case translated language is provided,
  // the function will return a translated version
  // the main language subtitle
  Future<Iterable<SubtitlesData>?> scrapeSubtitles({
    required String youtubeVideoId,
    required Language language,
    Language? translatedLanguage,
  }) async =>
      await _scraper
          .scrapeSubtitles(
            youtubeVideoId: youtubeVideoId,
            language: language,
            translatedLanguage: translatedLanguage,
          )
          .then(
            (scrapedSubtitles) => scrapedSubtitles?.map(
              (item) => SubtitlesData(
                subtitles: SubtitlesScraper._parseSubtitles(item.subtitles),
                isAutoGenerated: item.isAutoGenerated,
              ),
            ),
          );

// Helper function to fetch subtitles from the cache and return them as Subtitle data objects.
  Future<Iterable<SubtitlesData>?> _fetchCache({
    required String youtubeVideoId,
    required Language language,
  }) async {
    // Retrieve cached subtitles for the specified video and language.
    final cachedSubtitles = await cacheManager.retrieveSubtitles(
      videoId: youtubeVideoId,
      language: language.name,
    );

    // If no cached subtitles are found, return null; otherwise, parse and return Subtitle data objects.
    if (cachedSubtitles.isEmpty) return null;
    return cachedSubtitles.map((cachedSubtitlesItem) => SubtitlesData(
          subtitles: _parseSubtitles(cachedSubtitlesItem.subtitles),
          isAutoGenerated: cachedSubtitlesItem.isAutoGenerated,
        ));
  }

  static Iterable<subtitles_player.Subtitle> _parseSubtitles(String subtitles) {
    final List<subtitles_parser.Subtitle> parsedSubtitles =
        subtitles_parser.parseSubtitles(subtitles);
    return parsedSubtitles.map(
      (subtitle) => subtitles_player.Subtitle.fromMap(subtitle.toMap()),
    );
  }
}
