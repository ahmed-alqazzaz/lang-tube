import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_bundle.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_data.dart';
import 'package:languages/languages.dart';
import 'package:subtitles_parser/subtitles_parser.dart';
import 'package:subtitles_player/subtitles_player.dart';
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart';
import '../subtitles_cache_provider/cache_manager.dart';
import 'api_client.dart';
import 'data/exceptions.dart';
import 'package:quiver/iterables.dart';

@immutable
final class SubtitlesScraper {
  SubtitlesScraper({required this.cacheManager})
      : _scraper = YoutubeSubtitlesScraper(
          cacheManager: cacheManager,
          apiClient: ScraperApiClient(),
        );

  final YoutubeSubtitlesScraper _scraper;
  final SubtitlesCacheManager cacheManager;

  Stream<double> get downloadProgress => _scraper.activeProgress;

  // Function to fetch and process subtitles for a YouTube video in different languages.
  Future<Iterable<SubtitlesBundle>> fetchSubtitlesBundle({
    required String youtubeVideoId,
    required Language mainLanguage,
    required Language translatedLanguage,
  }) async =>
      await Future.wait<Iterable<SubtitlesData>>(
        [
          scrapeSubtitles(
            youtubeVideoId: youtubeVideoId,
            language: mainLanguage,
          ).then((value) =>
              value ?? (throw SubtitlesScraperNoCaptionsFoundException)),
          scrapeSubtitles(
            youtubeVideoId: youtubeVideoId,
            language: mainLanguage,
            translatedLanguage: translatedLanguage,
          ).then((value) =>
              value ?? (throw SubtitlesScraperNoCaptionsFoundException)),
        ],
        eagerError: true,
      ).then(
        (subtitlesPair) {
          // zip the list(of two) returned by future.wait
          return zip(subtitlesPair).map(
            (pair) => SubtitlesBundle(
              mainSubtitlesData: pair.first,
              translatedSubtitlesData: pair.last,
            ),
          );
        },
      );

  // in case translated language is provided,
  // the function will return a translated version
  // the main language subtitle
  Future<Iterable<SubtitlesData>?> scrapeSubtitles({
    required String youtubeVideoId,
    required Language language,
    Language? translatedLanguage,
  }) async {
    return
        // await _fetchCache(
        //       youtubeVideoId: youtubeVideoId,
        //       language: translatedLanguage ?? language,
        //     ) ??
        await _scraper
            .scrapeSubtitles(
      youtubeVideoId: youtubeVideoId,
      language: language,
      translatedLanguage: translatedLanguage,
    )
            .then(
      (scrapedSubtitles) async {
        if (scrapedSubtitles != null) {
          return Future.wait(
            scrapedSubtitles.map(
              (item) async => SubtitlesData(
                subtitles:
                    await SubtitlesScraper._parseSubtitles(item.subtitles),
                isAutoGenerated: item.isAutoGenerated,
              ),
            ),
          );
        }
        return null;
      },
    );
  }

// // Helper function to fetch subtitles from the cache and return them as Subtitle data objects.
//   Future<Iterable<SubtitlesData>?> _fetchCache({
//     required String youtubeVideoId,
//     required Language language,
//   }) async {
//     // Retrieve cached subtitles for the specified video and language.
//     final cachedSubtitles = await cacheManager.retrieveSubtitles(
//       videoId: youtubeVideoId,
//       language: language.name,
//     );

//     // If no cached subtitles are found, return null; otherwise, parse and return Subtitle data objects.
//     if (cachedSubtitles.isEmpty) return null;

//     return Future.wait(
//       cachedSubtitles.map(
//         (cachedSubtitlesItem) async => SubtitlesData(
//           subtitles: await _parseSubtitles(cachedSubtitlesItem.subtitles),
//           isAutoGenerated: cachedSubtitlesItem.isAutoGenerated,
//         ),
//       ),
//     );
//   }

  static Future<Iterable<Subtitle>> _parseSubtitles(String subtitles) async {
    final List<ParsedSubtitle> parsedSubtitles =
        await parseSubtitles(subtitles);
    return parsedSubtitles.map(
      (subtitle) => Subtitle.fromMap(subtitle.toMap()),
    );
  }

  Future<void> close() async => await cacheManager.close();
}
