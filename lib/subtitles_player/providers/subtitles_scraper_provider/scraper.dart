import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_bundle.dart';
import 'package:lang_tube/subtitles_player/providers/subtitles_scraper_provider/data/subtitles_data.dart';
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart';
import 'package:subtitles_parser/subtitles_parser.dart' as subtitles_parser;
import 'package:subtitles_player/subtitles_player.dart' as subtitles_player;
import '../subtitles_cache_provider/cache_manager.dart';
import 'api_client.dart';
import 'data/exceptions.dart';

@immutable
final class SubtitlesScraper {
  SubtitlesScraper({required this.cacheManager})
      : _scraper = YoutubeSubtitlesScraper(
          cacheManager: cacheManager,
          apiClient: ScraperApiClient(),
        );

  final YoutubeSubtitlesScraper _scraper;
  final SubtitlesCacheManager cacheManager;
  // Function to fetch and process subtitles for a YouTube video in different languages.
  Future<SubtitlesBundle> fetchSubtitlesBundle({
    required String youtubeVideoId,
    required String mainLanguage,
    required String translatedLanguage,
  }) async {
    return SubtitlesBundle(
      mainSubtitles: await fetchSubtitles(
            youtubeVideoId: youtubeVideoId,
            language: mainLanguage,
          ) ??
          (throw SubtitlesScraperNoCaptionsFoundException),
      translatedSubtitles: await () async {
        final x =
            // await fetchSubtitles(
            //       youtubeVideoId: youtubeVideoId,
            //       language: translatedLanguage,
            //     ) ??
            // If no translated subtitles were found, try translating the main subtitles.
            await _scrapeSubtitles<ScrapedSubtitles>(
                  youtubeVideoId: youtubeVideoId,
                  language: mainLanguage,
                ).then(
                  (scrapedMainSubtitles) async =>
                      await scrapedMainSubtitles?.first.translateTo('ar').then(
                            (translatedSubtitlesItem) =>
                                [translatedSubtitlesItem.toSubtitleData],
                          ),
                ) ??
                (throw SubtitlesScraperNoCaptionsFoundException);
        // log("scraped ${x.first.subtitles.toList()}");
        return x;
      }(),
    );
  }

  // Fetch subtitles from cache or scrape them from YouTube.
  Future<Iterable<SubtitlesData>?> fetchSubtitles({
    required String youtubeVideoId,
    required String language,
  }) async {
    try {
      return
          // await _fetchCache(
          //       youtubeVideoId: youtubeVideoId,
          //       language: language,
          //     ) ??
          await _scraper
              .scrapeSubtitles(
                  youtubeVideoId: youtubeVideoId, language: language)
              .asyncMap(
        (scrapedSubtitlesItem) {
          return scrapedSubtitlesItem.toSubtitleData;
        },
      ).toList();
    } catch (e) {
      log(e.toString());
      rethrow;
    }
    ;
  }

  // Generic helper function to fetch and process subtitles for a given language.
  Future<List<T>?> _scrapeSubtitles<T>({
    required String youtubeVideoId,
    required String language,
  }) async {
    assert([SubtitlesData, ScrapedSubtitles].contains(T), 'Unsupported type');

    // Scrape subtitles using the YouTube scraper and parse them into the desired type.
    final subtitles = await _scraper
        .scrapeSubtitles(youtubeVideoId: youtubeVideoId, language: language)
        .asyncMap(
      (scrapedSubtitlesItem) {
        if (T is SubtitlesData) {
          return scrapedSubtitlesItem.toSubtitleData as T;
        }
        return scrapedSubtitlesItem as T;
      },
    ).toList();

    // Return subtitles if any are found, or null if none are available.
    return subtitles.isNotEmpty ? subtitles : null;
  }

// Helper function to fetch subtitles from the cache and return them as Subtitle data objects.
  Future<Iterable<SubtitlesData>?> _fetchCache({
    required String youtubeVideoId,
    required String language,
  }) async {
    // Retrieve cached subtitles for the specified video and language.
    final cachedSubtitles = await cacheManager.retrieveSubtitles(
      videoId: youtubeVideoId,
      language: language,
    );

    // If no cached subtitles are found, return null; otherwise, parse and return Subtitle data objects.
    if (cachedSubtitles.isEmpty) return null;
    return cachedSubtitles.map((cachedSubtitlesItem) => SubtitlesData(
          subtitles: _parseSubtitles(cachedSubtitlesItem.subtitles),
          isAutoGenerated: cachedSubtitlesItem.isAutoGenerated,
        ));
  }

  static Iterable<subtitles_player.Subtitle> _parseSubtitles(String subtitles) {
    final List<subtitles_parser.Subtitle> parsedSubtitles =
        subtitles_parser.parseSubtitles(subtitles);
    return parsedSubtitles.map(
      (subtitle) => subtitles_player.Subtitle.fromMap(subtitle.toMap()),
    );
  }
}

extension on ScrapedSubtitles {
  SubtitlesData get toSubtitleData => SubtitlesData(
        subtitles: SubtitlesScraper._parseSubtitles(subtitles),
        isAutoGenerated: isAutoGenerated,
      );
}
