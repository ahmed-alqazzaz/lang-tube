import 'package:collection/collection.dart';
import 'package:core_utils/core_utils.dart';
import 'package:flutter/material.dart';
import 'package:lang_tube/crud/subtitles_cache_manager/utils.dart';
import 'package:path_provider/path_provider.dart';
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart'
    as subtitles_scraper;
import 'package:youtube_subtitles_scraper/youtube_subtitles_scraper.dart';

import '../../models/subtitles/cached_source_captions.dart';
import 'constants.dart';
import 'db_manager.dart';

@immutable
final class SubtitlesCacheManager implements subtitles_scraper.CacheManager {
  const SubtitlesCacheManager._(this._dbManager);
  final SubtitlesDbManager _dbManager;

  static Future<SubtitlesCacheManager> open() async => SubtitlesCacheManager._(
        await SubtitlesDbManager.open('${await _cachePath}$subtitlesDbName'),
      );

  @override
  Future<void> cacheSubtitles(ScrapedSubtitles scrapedSubtitles) async {
    await _dbManager.addVideoIdIfNotPresent(scrapedSubtitles.videoId);
    final subtitlesInfoId = await _dbManager.insertSubtitlesInfoIfNotPresent(
      videoId: scrapedSubtitles.videoId,
      language: scrapedSubtitles.language?.name ?? 'unkown',
      isAutoGenerated: scrapedSubtitles.isAutoGenerated,
    );
    await _dbManager.insertSubtitles(
      subtitles: scrapedSubtitles.subtitles.toJson(),
      subtitlesInfoId: subtitlesInfoId,
    );
  }

  @override
  Future<void> cacheSourceCaptions(SourceCaptions captions) async {
    await _dbManager.addVideoIdIfNotPresent(captions.videoId);
    final subtitlesInfoId = await _dbManager.insertSubtitlesInfoIfNotPresent(
      videoId: captions.videoId,
      language: captions.language?.name ?? 'unknown',
      isAutoGenerated: captions.isAutoGenerated,
    );
    await _dbManager.insertSubtitlesSource(
      subtitlesSource: captions.uri.toString(),
      subtitlesInfoId: subtitlesInfoId,
    );
  }

  @override
  Future<Iterable<ScrapedSubtitles>> retrieveSubtitles({
    String? videoId,
    String? language,
    bool sortByFirstCacheDate = true,
  }) async =>
      await _dbManager.retrieveSubtitles().then((subtitlesList) {
        subtitlesList = subtitlesList.where(
          (subtitles) => videoId != null ? subtitles.videoId == videoId : true,
        );
        subtitlesList = subtitlesList.where(
          (subtitles) =>
              language != null ? subtitles.language?.name == language : true,
        );

        return sortByFirstCacheDate
            ? subtitlesList.sorted(
                (a, b) =>
                    (a.cacheCreationDate != null && b.cacheCreationDate != null
                            ? a.cacheCreationDate!.isAfter(b.cacheCreationDate!)
                            : false)
                        .toInt(),
              )
            : subtitlesList;
      });

  @override
  Future<Iterable<CachedSourceCaptions>> retrieveSources({
    String? videoId,
    String? language,
    bool sortByFirstCacheDate = true,
  }) async =>
      await _dbManager.retrieveAllSources().then(
        (sources) {
          sources = sources.where(
            (source) => videoId != null ? source.videoId == videoId : true,
          );
          sources = sources.where(
            (source) =>
                language != null ? source.language?.name == language : true,
          );

          return sortByFirstCacheDate
              ? sources.sorted(
                  (a, b) => (a.cacheCreationDate != null &&
                              b.cacheCreationDate != null
                          ? a.cacheCreationDate!.isAfter(b.cacheCreationDate!)
                          : false)
                      .toInt(),
                )
              : sources;
        },
      );

  @override
  Future<void> clearSubtitlesCache() => _dbManager.deleteAllSubtitles();
  @override
  Future<void> clearSources({String? videoId, bool? isAutoGenerated}) async {
    if (isAutoGenerated != null) assert(videoId != null);
    await _dbManager.deleteSubtitlesSources(
      videoId: videoId,
      isAutoGenerated: isAutoGenerated,
    );
  }

  Future<void> close() async => await _dbManager.close();

  static Future<String> get _cachePath async =>
      await getTemporaryDirectory().then((dir) => dir.path);
}
